import java.io.File

/**
 * @author Ana Mercês Soares dos Reis Moreira - nº99352
 * @author Inês Colaço Ascenso - nº99286
 */

/**
 * Class that represents an attribute with a name and a value.
 * @property[name] Name of the attribute.
 * @property[value] Value of the attribute.
 */
class Attribute(
    private var name: String?,
    private var value: String?
){
    /**
     * Initializes an instance of Attribute.
     *
     * If the name given has more than one word, the attribute is not created
     * @param[name] The name given to the attribute
     */
    init {
        require(name?.split(" ")?.size == 1) {
            "Name must contain only one word"
        }
    }

    /**
     * Returns a String representation of the attribute.
     * @return A String representation of the attribute.
     */
    override fun toString(): String {
        return "Attribute(name='$name', value='$value')"
    }

    fun get_attribute_name(): String? {
        return name
    }

    fun get_attribute_value(): String? {
        return value
    }

    fun set_attribute_name(name: String) {
        this.name = name
    }

    fun set_attribute_value(value: String) {
        this.value = value
    }


    /**
     * Verifies if the attribute in question is equal to another attribute.
     *
     * @param[other] The other object of the comparison.
     * @return True: if the other object is also an Attribute and has the same name and value as the first one.
     * False: otherwise.
     */
    override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is Attribute) return false

            if (name != other.name || value != other.value) return false

            return true
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + value.hashCode()
        return result
    }

}

/**
 * Class that represents an entity with a name, a text, a list of attributes, a parent and a list of children.
 * @property[name] Name of the entity.
 * @property[text] Text of the entity.
 * @property[attributes] List of attributes of the entity.
 * @property[parent] Parent of the entity.
 * @property[children] List of children (also entities) generated by the entity.
 */

class Entity(
    private var name: String,
    private var text: String = "",
    private val attributes: MutableList <Attribute> = mutableListOf(),
    private val parent: Entity? = null,
    private val children: MutableList<Entity> = mutableListOf()

    ){

    /**
     * Initializes an instance of Entity.
     *
     * If the name given has more than one word, the entity is not created
     * @param[name] The name given to the entity
     *
     * If a parent entity is given, adds the entity to the list of children of the parent.
     * @param[parent] The parent of the entity. If it is null, this entity will be considered a root entity.
     */
    init{
        require(name.split(" ").size == 1) {
            "Name of entity must contain only one word"
        }
        if (parent?.get_entity_text()?.isNotBlank() == true)
            throw IllegalStateException("Parent entity already has text and cannot have children.")
        parent?.children?.add(this)
    }

    /**
     * Returns a String representation of the entity.
     * @return A String representation of the entity.
     */
    override fun toString(): String {
        return "Entity(name='$name')"
    }

    /**
     * Accepts a visitor function to process this entity.
     *
     * This function invokes the provided [visitor] function passing this entity as its argument.
     * The visitor function is expected to return a boolean value.
     *
     * @param[visitor] The visitor function to be invoked with this entity as its argument.
     * @return The boolean value returned by the visitor.
     */
    fun accept(visitor: (Entity) -> Boolean){
        visitor(this)
    }

    fun get_name(): String {
        return name
    }

    fun set_name(name: String){
        this.name=name
    }

    private fun equal_attribute(name: String?, value: String?): Attribute? {
        return attributes.find { it.get_attribute_name().equals(name) && it.get_attribute_value().equals(value) }
    }

    // Relating Attributes

    // Point 2.
    /**
     * Adds a given [attribute] to the list of attributes of the entity.
     * @param[attribute] The attribute to be added to the entity.
     */
    fun add_attribute(attribute: Attribute){
        if (equal_attribute(attribute.get_attribute_name(), attribute.get_attribute_value()) != null) {
            throw IllegalStateException("Entity already has this attribute.")
        } else {
            this.attributes.add(attribute)
        }
    }

    // Point 2.
    /**
     * Removes a given [attribute] from the list of attributes of the entity.
     * @param[attribute] The attribute to be removed from the entity.
     */
    fun remove_attribute(attribute: Attribute){
        attributes.removeIf { it == attribute }
    }

    // Point 2.
    /**
     * Changes the name and/or the value of a given [attribute].
     * Searches for the given attribute in the list of attributes of the entity and updates the name and/or value.
     *
     * @param[attribute] The attribute to be changed.
     * @param[new_name] The name of the attribute to replace the current name. By default, it's null, if there is no change.
     * @param[new_value] The value of the attribute to replace the current value. By default, it's null, if there is no change.
     */
    fun change_attribute(attribute: Attribute, new_name: String? = null, new_value: String? = null) {
//        attributes.forEach {
//            if (it == attribute) {
//                if (new_name != null) {
//                    require(new_name.split(" ").size == 1) {
//                        "New name must contain only one word"
//                    }
//                    val last_name = it.name
//                    it.name = new_name
//                    if (attributes.filter{ attribute.name == it.name && attribute.value == it.value}.size != 0){
//                        print("This entity already has one equal attribute")
//                        it.name = last_name
//                    }
//                }
//                if (new_value != null) {
//                    val last_value = it.value
//                    it.value = new_value
//                    if (attributes.filter{ attribute.name == it.name && attribute.value == it.value}.size != 0){
//                        print("This entity already has one equal attribute")
//                        it.value = last_value
//                    }
//                }
//            }
//        }



        attributes.forEach {
            if (it == attribute) {

                var aux_name = new_name
                var aux_value = new_value

                if (new_name == null)
                    aux_name = it.get_attribute_name()
                if (new_value == null)
                    aux_value = it.get_attribute_value()

                if (equal_attribute(aux_name, aux_value) != null) {
                    throw IllegalStateException("Entity already has this attribute.")
                } else {
                    if (new_name != null)
                        it.set_attribute_name(new_name)
                    if (new_value != null)
                        it.set_attribute_value(new_value)
                }
            }
        }
    }

    /**
     * Getter of the list of attributes of the entity.
     * @return List of attributes of the entity.
     */
    fun get_attributes(): MutableList<Attribute>{
        return this.attributes
    }

    // Relating entities text
    /**
     * Getter of the text that belongs to the entity.
     * @return Text related to the entity.
     */
    fun get_entity_text(): String{
        return this.text
    }

    /**
     * Changes the text of the entity.
     * Updates the current text with the given [new_text].
     * @param[new_text] The text to replace the current text of the entity.
     */
    fun change_entity_text(new_text: String){
        if (children.isNotEmpty()) {
            throw IllegalStateException("Entity already has children and cannot have text.")
        }
        text=new_text
    }

    /**
     * Removes the text of the entity.
     * Clears the current text of the entity, sets it to an empty String ("").
     *
     */
    fun remove_entity_text(){
        text=""
    }

    // Relating parent and childrens

    // Point 3.
    /**
     * Getter of the entity's parent.
     * If the parent doesn't exist, the entity is the root and will return null.
     * @return The parent of the entity. If there is no parent, it returns null.
     */
    fun get_parent(): Entity?{
        return this.parent
    }

    // Point 3.
    /**
     * Getter of all the descendants of the entity (children, grandchildren, great-grandchildren, etc.).
     *
     * It gets recursively the children of each entity that is related to the entity, placing its direct and
     * indirect descendants into a list and returning it at the end.
     *
     * @return List of all the descendant entities of the entity.
     */
    // Counting the children of the children
    fun get_all_children() : List<Entity> {
        val list: MutableList<Entity> = mutableListOf()
        this.children.forEach {
            list.add(it)
            list.addAll(it.get_all_children())
        }
        return list
    }

    // Point 3.
    /**
     * Getter of the direct children of the entity.
     * @return List of children of the entity.
     */
    // Not counting the children of the children
    fun get_children() : List<Entity> {
        return this.children
    }

    // Point 3.
    /**
     * Getter of the parent and the direct children of the entity.
     *
     * Verifies if the entity has a parent. If so adds it to the list just created.
     * Adds all the entity's children to that same list.
     *
     * @return List with the parent of the entity and its children.
     */
    fun get_parent_and_children(): List<Entity>{

        val list = mutableListOf<Entity>()
        this.get_parent()?.let { parent ->
            list.add(parent)
        }
        list.addAll(this.get_children())

        return list
    }
}

/**
 * Class that represents a document with a name and a list of entities.
 * @property[name] Name of the document.
 * @property[entities] List of entities contained in the document.
 */
class Document(
    private var child: Entity,
    private val entities: MutableList <Entity> = mutableListOf(),
    private val encoding: String
) {

    /**
     * Accepts a visitor function to process this entity and its children.
     *
     * Applies the provided [visitor] function to this entity and recursively to all of its children.
     * The visitor function should return true to continue visiting other entities, or false to stop the process.
     * @param visitor The visitor function to be applied to this entity and its children.
     */
    fun accept(visitor: (Entity) -> Boolean) {
        entities.forEach {
                it.accept(visitor)
        }
    }

    fun get_child(): Entity {
        return child
    }

    fun get_entities(): List<Entity> {
        return entities
    }

    internal fun attribute_exists(entity: Entity, attribute: Attribute): Attribute? {
        return entity.get_attributes().find { it.get_attribute_name() == attribute.get_attribute_name() && it.get_attribute_value() == attribute.get_attribute_value() }
    }

    internal fun entity_exists(name: String, text: String, attributes: MutableList<Attribute>, parent: Entity?, children: List<Entity>): Entity? {
        return get_entities().find { it.get_name() == name && it.get_entity_text() == text && it.get_attributes() == attributes
                && it.get_parent() == parent && it.get_children() == children}
    }

    // Point 1.
    /**
     * Adds an entity to the document.
     * Adds to the list of entities the [entity].
     * @param[entity] The entity to be added to the document.
     */
    fun add_entity_to_document(entity: Entity) {
        if (entity_exists(entity.get_name(), entity.get_entity_text(), entity.get_attributes(), entity.get_parent(), entity.get_children()) != null) {
            throw IllegalStateException("Document already has this entity.")
        } else {
            entities.add(entity)
        }

    }

    // Point 1.
    /**
     * Removes an entity from the document.
     * It goes to the list of entities of the document and removes the one given as [entity].
     * @param[entity] The entity to be removed from the document.
     */
    fun remove_entity(entity: Entity) {
        entities.removeIf { it == entity }
    }

    // Point 4.
    /**
     * Does the pretty print by calling an auxiliary function.
     * @param[entity] The root entity or the entity where the pretty print begins.
     * @return Call another function that deals with the construction of the structure of the xml File.
     */
    fun pretty_print(entity: Entity): String {
        return get_entity_xml(entity = entity, pretty_print = true, encoding)
    }

    // Point 4.
    /**
     * Does the pretty print and write it down in a given File.
     * @param[entity] The root entity or the entity where the pretty print begins.
     * @param[outputFile] File where the pretty print should be written
     * @return Call another function that deals with the construction of the structure of the xml File and
     * write it in the File.
     */
    fun pretty_print_to_file(entity: Entity, outputFile: File) {
        val xmlString = pretty_print(entity)
        outputFile.writeText(xmlString)
    }

    // Point 6.
    /**
     * Adds attributes to the document globally.
     *
     * Creates a new attribute with the [attribute_name] and the [attribute_value].
     * Filters from the document's list of entities those which have the name [entity_name].
     * The attribute just created is added to those entities.
     *
     * @param[entity_name] Name of the entities to which an attribute will be added.
     * @param[attribute_name] Name of the attribute to be added.
     * @param[attribute_value] Value of the attribute to be added.
     */
    fun add_global_attribute(entity_name: String, attribute_name: String, attribute_value: String) {
//        val attribute = Attribute(attribute_name, attribute_value)
//
//        this.entities.filter { it.name == entity_name }
//            .forEach {
//                if (it.attributes.filter{ attribute.name == attribute_name && attribute.value == attribute_value }.size == 0){
//                    it.add_attribute(attribute)
//                } else {
//
//                    print("The entity already has this attribute")
//                }
//
//            }

        require(attribute_name.split(" ").size == 1) {
            "New name must contain only one word"
        }

        val att = Attribute(attribute_name, attribute_value)

        this.entities.filter { it.get_name() == entity_name }
            .forEach {
                if (attribute_exists(it, att) != null) {
                    throw IllegalStateException("Entity already has this attribute.")
                } else {
                    it.add_attribute(att)
                }

            }
    }

    // Point 7.
    /**
     * Renames entities to the document globally.
     *
     * It searches from the document's list of entities those which name is [old_name].
     * Renames those entities with [new_name].
     *
     * @param[old_name] Current name of the entities - to be renamed.
     * @param[new_name] Future name of the entities - to replace the current.
     */
    fun rename_global_entity(old_name: String, new_name:String){
        require(new_name.split(" ").size == 1) {
                "New name must contain only one word"
        }

        this.entities.filter { old_name == it.get_name() }
            .forEach { entity ->
                if (entity_exists(new_name, entity.get_entity_text(), entity.get_attributes(), entity.get_parent(), entity.get_children()) != null) {
                    throw IllegalStateException("Document already has this entity.")
                } else {
                    entity.set_name(new_name)
                }
            }
    }

    // Point 8.
    /**
     * Renames attributes of the document globally.
     *
     * Checks the document's list of entities and verifies if there are any entities with the name [entity_name].
     * If so, goes through the list of attributes of each one of those entities and verifies if there are any attributes
     * with the same name as the [old_attribute_name].
     * If so, renames the current name of that attribute to [new_attribute_name].
     *
     * @param[entity_name] Name of the entities where the attributes are.
     * @param[old_attribute_name] Current name of the attribute - to be renamed.
     * @param[new_attribute_name] Future name of the attribute - to replace the current.
     */
    fun rename_global_attributes(entity_name: String, old_attribute_name: String, new_attribute_name: String){
        require(new_attribute_name.split(" ").size == 1) {
                "New name must contain only one word"
        }
        entities.forEach{ entity ->
            if (entity_name == entity.get_name()) {
                entity.get_attributes().forEach{
                    if (it.get_attribute_name() == old_attribute_name)
                        entity.change_attribute(attribute = it, new_name = new_attribute_name)
                }
//                it.attributes.forEach{
//                    if (it.get_attribute_name()==old_attribute_name)
//                        it.set_attribute_name(new_attribute_name)
//                }

            }
        }
    }

    // Point 9.
    /**
     * Removes the entity from the document globally.
     *
     * Goes through the document's list of entities and verifies if there are any entities with the same name as [entity_name].
     * If so, adds them to the list recently created.
     * At the end, removes the list of unwanted entities from the document's list of entities.
     *
     * @param[entity_name] Name of the entity to be removed.
     */
    fun remove_global_entities(entity_name: String){
        val list: MutableList <Entity> = mutableListOf()

        this.entities.filter { it.get_name() == entity_name }
            .forEach {
                list.add(it)
            }
        entities.removeAll(list)
    }

    // Point 10.
    /**
     * Removes attributes of the document globally.
     *
     * Iterates over the document's list of entities and removes the attributes which name is [attribute_name]
     * and belong to the entities which name is [entity_name].
     *
     * @param[entity_name] Name of the entities which contain the attributes.
     * @param[attribute_name] Name of the attributes to be removed.
     */
    fun remove_global_attributes(entity_name: String, attribute_name: String) {
        entities.forEach { entity ->
            if (entity_name == entity.get_name()) {
                val attributes_to_remove = entity.get_attributes().filter { it.get_attribute_name() == attribute_name }
                entity.get_attributes().removeAll(attributes_to_remove)
            }
        }
    }

    /**
     * Creates a String that contains the elements of each entity (name, text, attributes).
     *
     * If it's called by the "pretty_print" function, the Boolean variable "pretty_print" will be True
     * and so the String of the entity's children will also be added recursively to the structure.
     *
     * @param[entity] The entity where the pretty print should start. If there is no pretty print, it's
     * the entity String.
     * @param[pretty_print] Defines if it's a String or a pretty print structure.
     * @return Structure of the resulting pretty print.
     */
    fun get_entity_xml(entity: Entity, pretty_print: Boolean = false, encoding: String? = null, indent: String = ""): String{
        val stringBuilder = StringBuilder()

        if(encoding != null) {
            stringBuilder.append("<${encoding}>")
            stringBuilder.appendLine()
        }

        stringBuilder.append("$indent<${entity.get_name()}")
        if (entity.get_attributes().isNotEmpty()) {
            entity.get_attributes().forEach { attribute ->
                stringBuilder.append(" ${attribute.get_attribute_name()}=\"${attribute.get_attribute_value()}\"")
            }
        }

        if (entity.get_children().isEmpty() && entity.get_entity_text().isEmpty()) {
            stringBuilder.append("/>")
        } else {
            stringBuilder.append(">")

            if (entity.get_entity_text().isNotEmpty())
                stringBuilder.append(entity.get_entity_text())

            // In case pretty_print is True, it will get the children structure too
            if (pretty_print){
                if (entity.get_children().isNotEmpty()) {
                    stringBuilder.appendLine()
                    entity.get_children().forEach { child ->
                        stringBuilder.append(get_entity_xml(entity=child, pretty_print=true ,indent="$indent    "))
                        stringBuilder.appendLine()
                    }
                    stringBuilder.append(indent)
                }
            }
            if (entity.get_children().isNotEmpty() || entity.get_entity_text().isNotEmpty()) {
                stringBuilder.append("</${entity.get_name()}>")
            }
        }
        return stringBuilder.toString()
    }

    /**
     * For each split in the XPath String ("/"), it searches for the entity name where is equal to the first
     * sub-string of the split (entity most to the left of the split character) - "first_entity".
     *
     * If it finds entities that exist in the [entities_to_explore] list and the entities have the same name as
     * the first sub-string, there are 2 possible scenarios:
     *
     *      1st - the path ends up there, which means the "other_entities" variable is empty and adds the entity to
     * "foundEntities" list.
     *
     *      2nd - there are more entities in the path and so calls the function to its children.
     *
     * At the end of the path, if the entity exists, it is added to the list of foundEntities.
     *
     * @param[x_path] Micro-XPath with the possible path of entities.
     * @param[entities_to_explore] Document's list of entities.
     * @return List of the found entities.
     */
    private fun aux_get_entity_with_x_path(x_path: String, entities_to_explore: List<Entity>): List<Entity> {
    val foundEntities = mutableListOf<Entity>()

    val parts = x_path.split("/")
    val first_entity = parts.first()
    val other_entities = parts.drop(1).joinToString("/")

    val matchingEntities = entities_to_explore.filter { it.get_name() == first_entity }

    matchingEntities.forEach { entity ->
        if (other_entities.isEmpty()) {
            foundEntities.add(entity)
        } else {
            val childEntities = aux_get_entity_with_x_path(other_entities, entity.get_children())
            foundEntities.addAll(childEntities)
        }
    }

    return foundEntities
}

    // Micro-XPath
    /**
     * Given a path, joins all the entities that the auxiliary function "aux_get_entity_with_x_path"
     * relates to the [x_path].
     *
     * @param[x_path] Micro-XPath with the possible path of entities.
     * @return String with the final path of the found entities.
     */
    fun get_entity_with_x_path(x_path: String): String {
        val stringBuilder = StringBuilder()
        val returned_entities = aux_get_entity_with_x_path(x_path, entities)

        if (returned_entities.isNotEmpty()) {
            returned_entities.forEachIndexed { index, entity ->
                stringBuilder.append(get_entity_xml(entity))
                if (index != returned_entities.size - 1)
                    stringBuilder.append("\n")
            }
        }
        return stringBuilder.toString()
    }
}

/**
 * NOTE: The following functions are another version of the exercises using visitors.
 * These functions are related to the class Document.
 */
// Functions using Visitors (Point 5.)

// Relating Entities, using Documents
// The functions must be related to a Document, so that the entities available in it are searched, when using the Visitor method.

// Point 3.
/**
 * Searches for the parent of an entity.
 *
 * Looks for the parent of the given [child_entity] from the root of the document's hierarchy of entities.
 *
 * @param[child_entity] The child entity for which to find the parent.
 * @return The parent entity of the [child_entity]. If not found, returns null.
 */
fun Document.get_parent_vis(child_entity: Entity): Entity?{
    var result: Entity? = null

    this.accept { entity ->
        if (entity == child_entity.get_parent()) {
            result = entity
        }
        true
    }
    return result
}

// Point 3.
/**
 * Searches for the children of an entity.
 *
 * Starts looking for the children at the beginning of the document's structure and saves all the children
 * whose parent is the [parent_entity].
 *
 * @param[parent_entity] The parent entity for which to find its children.
 * @return The list of children of the [parent_entity].
 */
fun Document.get_children_vis(parent_entity: Entity) : List<Entity> {
    val list = mutableListOf<Entity>()

    this.accept { entity ->
        if (entity.get_parent() == parent_entity){
            list.add(entity)
        }
        true
    }
    return list
}

// Point 7.
/**
 * Looks for the parent and children of an entity.
 *
 * Starts at the root of the document and seeks the parent of the [main_entity] and the entity's children.
 * As it goes on the hierarchy, it saves the entities in a list.
 *
 * @param[main_entity] The entity for which to find its parent and children.
 * @return List with the parent and children of the entity given.
 */
fun Document.get_parent_and_children_vis(main_entity: Entity): List<Entity>{
    val list = mutableListOf<Entity>()

    this.accept { entity ->
        if (entity in main_entity.get_children() || entity == main_entity.get_parent()) {
            list.add(entity)
        }
        true
    }
    return list
}

// Relating Documents

// Point 6.
/**
 * Adds a global attribute to a document.
 *
 * Creates an attribute with the [attribute_name] and the [attribute_value].
 * Looks for the entities which name is the same as the [entity_name].
 * As it goes on the hierarchy, it adds the recently created attribute as a global attribute to the entities
 * which verify the previous condition.
 *
 * @param[entity_name] Name of the entities to which the attribute will be added.
 * @param[attribute_name] Name of the attribute to be added.
 * @param[attribute_value] Value of the attribute ti be added.
 */
fun Document.add_global_attribute_vis(entity_name: String, attribute_name: String, attribute_value: String) {
    val att = Attribute(attribute_name, attribute_value)

    this.accept {
        if (entity_name == it.get_name()) {
            if (attribute_exists(it, att) != null) {
                throw IllegalStateException("Entity already has this attribute.")
            } else {
                it.add_attribute(att)
            }
        }
        true
    }
}

// Point 7.
/**
 * Renames entities to the document globally.
 *
 * It goes through the hierarchy of the document and looks for the entities which name is [old_name].
 * Renames them with [new_name].
 *
 * @param[old_name] Current name of the entities - to be renamed.
 * @param[new_name] Future name of the entities - to replace the current.
 */
fun Document.rename_global_entity_vis(old_name: String, new_name:String){
    require(new_name.split(" ").size == 1) {
        "New name must contain only one word"
    }
    this.accept { entity ->
        if (old_name == entity.get_name()) {
            if (entity_exists(new_name, entity.get_entity_text(), entity.get_attributes(), entity.get_parent(), entity.get_children()) != null) {
                throw IllegalStateException("Document already has this entity.")
            } else {
                entity.set_name(new_name)
            }
        }
        true
    }
}

// Point 8.
/**
 * Renames global attributes of the document.
 *
 * Starting at the root, goes through the hierarchy of entities of the document and renames the global attributes
 * of the entities which name is [entity_name].
 * Changes the name of the global attributes which current name is [old_attribute_name] to [new_attribute_name].
 *
 * @param[entity_name] Name of the entities where the attributes are.
 * @param[old_attribute_name] Current name of the attributes - to be renamed.
 * @param[new_attribute_name] Future name of the attributes - to replace the current.
 */
fun Document.rename_global_attributes_vis(entity_name: String, old_attribute_name: String, new_attribute_name: String){
    require(new_attribute_name.split(" ").size == 1) {
        "New name must contain only one word"
    }

    this.accept { entity ->
        if (entity_name == entity.get_name()) {
            entity.get_attributes().forEach{
                if (it.get_attribute_name() == old_attribute_name)
                    entity.change_attribute(attribute = it, new_name = new_attribute_name)
            }
        }
        true
    }
}

// Point 9.
/**
 * Removes the entity from the document globally.
 *
 * Goes through the hierarchy of the document, starting at the root, and looks for the entities which name is
 * [entity_name]. Removes from the document's entities list those which fulfill the previous condition.
 *
 * @param[entity_name] Name of the entities to be removed.
 */
fun Document.remove_global_entities_vis(entity_name: String) {
    val list = mutableListOf<Entity>()

    this.accept { entity ->
        if (entity.get_name() == entity_name) {
            list.add(entity)
        }
        true
    }
    list.forEach { remove_entity(it) }
}

// Point 10.
/**
 * Removes attributes of the document globally.
 *
 * Starts at the beginning of the hierarchy of the document and looks for the entities which name is [entity_name].
 * Filters the attributes which name is [attribute_name] and when found all the entities and respective attributes,
 * removes all those attributes globally from the document.
 *
 * @param[entity_name] Name of the entities which contain the attributes.
 * @param[attribute_name] Name of the attributes to be removed.
 */
fun Document.remove_global_attributes_vis(entity_name: String, attribute_name: String) {
    this.accept { entity ->
        if (entity_name == entity.get_name()) {
            val attributesToRemove = entity.get_attributes().filter { it.get_attribute_name() == attribute_name }
            attributesToRemove.forEach { attribute ->
                entity.get_attributes().remove(attribute)
            }
        }
        true
    }
}

