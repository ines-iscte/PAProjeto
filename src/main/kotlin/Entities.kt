import java.io.File

/**
 * @author Ana Mercês Soares dos Reis Moreira - nº99352
 * @author Inês Colaço Ascenso - nº99286
 */

/**
 * Class that represents an attribute with a name and a value.
 * @property[name] Name of the attribute.
 * @property[value] Value of the attribute.
 */
class Attribute(
    var name: String,
    var value: String
){
    /**
     * Returns a String representation of the attribute.
     * @return A String representation of the attribute.
     */
    override fun toString(): String {
        return "Attribute(name='$name', value='$value')"
    }

    /**
     * Verifies if the attribute in question is equal to another type of object.
     *
     * @param[other] The other object of the comparison.
     * @return True: if the other object is also an Attribute and has the same name and value as the first one.
     * False: otherwise.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Attribute) return false

        if (name != other.name || value != other.value) return false

        return true
    }
}

/**
 * Class that represents an entity with a name, a text, a list of attributes, a parent and a list of children.
 * @property[name] Name of the entity.
 * @property[text] Text of the entity.
 * @property[attributes] List of attributes of the entity.
 * @property[parent] Parent of the entity.
 * @property[children] List of children (also entities) generated by the entity.
 */

class Entity(
    var name: String,
    var text: String = "",
    val attributes: MutableList <Attribute> = mutableListOf(),
    val parent: Entity? = null,
    val children: MutableList<Entity> = mutableListOf()

    ){

    /**
     * Initializes an instance of Entity.
     *
     * If a parent entity is given, adds the entity to the list of children of the parent.
     * @param[parent] The parent of the entity. If it is null, this entity will be considered a root entity.
     */
    init{
        if (parent != null) {
            parent.children.add(this)
        }

    }

    /**
     * Returns a String representation of the entity.
     * @return A String representation of the entity.
     */
    override fun toString(): String {
        return "Entity(name='$name')"
    }

    /**
     * Accepts a visitor function to process this entity.
     *
     * This function invokes the provided [visitor] function passing this entity as its argument.
     * The visitor function is expected to return a boolean value.
     *
     * @param[visitor] The visitor function to be invoked with this entity as its argument.
     * @return The boolean value returned by the visitor.
     */
    //Dunno
    fun accept(visitor: (Entity) -> Boolean){
        visitor(this)
    }

    // Atributos

    /**
     * Adds a given [attribute] to the list of attributes of the entity.
     * @param[attribute] The attribute to be added to the entity.
     */
    fun addAttribute(attribute: Attribute){
        this.attributes.add(attribute)
    }

    /**
     * Removes a given [attribute] from the list of attributes of the entity.
     * @param[attribute] The attribute to be removed from the entity.
     */
    fun removeAttribute(attribute: Attribute){
//        attributes.forEach(){
//            if(it == attribute)
//                attributes.remove(it)
//        }
        attributes.removeIf { it == attribute }
    }

    /**
     * Changes the name and/or the value of a given [attribute].
     * Searches for the given attribute in the list of attributes of the entity and updates the name and/or value.
     *
     * @param[attribute] The attribute to be changed.
     * @param[new_name] The name of the attribute to replace the current name. By default, it's null, if there is no change.
     * @param[new_value] The value of the attribute to replace the current value. By default, it's null, if there is no change.
     */
    fun changeAttribute(attribute: Attribute, new_name: String? = null, new_value: String? = null) {
        attributes.forEach {
            if (it == attribute) {
                if (new_name != null) {
                    it.name = new_name
                }
                if (new_value != null) {
                    it.value = new_value
                }
            }
        }
    }

    /**
     * Getter of the list of attributes of the entity.
     * @return List of attributes of the entity.
     */
    fun get_attributes(): MutableList<Attribute>{
        return this.attributes
    }

    /**
     * Getter of the text that belongs to the entity.
     * @return Text related to the entity.
     */
    // Texto
    fun get_entity_text(): String{
        return this.text
    }

    /**
     * Changes the text of the entity.
     * Updates the current text with the given [new_text].
     * @param[new_text] The text to replace the current text of the entity.
     */
    fun change_entity_text(new_text: String){
        text=new_text
    }

    /**
     * Removes the text of the entity.
     * Clears the current text of the entity, sets it to an empty String ("").
     *
     */
    fun remove_entity_text(){
        text=""
    }

    // Entidade mãe e entidades aninhadas

    /**
     * Getter of the entity's parent.
     * If the parent doesn't exist, the entity is the root and will return null.
     * @return The parent of the entity. If there is no parent, it returns null.
     */
    fun get_Parent(): Entity?{
        return this.parent
    }

    /**
     * Getter of all the descendants of the entity (children, grandchildren, great-grandchildren, etc.).
     *
     * It gets recursively the children of each entity that is related to the entity, placing its direct and
     * indirect descendants into a list and returning it at the end.
     *
     * @return List of all the descendant entities of the entity.
     */
    // Ao contar com os filhos das entidades filhas
    fun get_all_Children() : List<Entity> {
        val list: MutableList<Entity> = mutableListOf()
        this.children.forEach {
            //if (it is Entity) {
            list.add(it)
            list.addAll(it.get_all_Children())
            //}
        }
        return list
    }

    /**
     * Getter of the direct children of the entity.
     * @return List of children of the entity.
     */
    // Sem contar com os filhos das entidades filhas
    fun get_Children() : List<Entity> {
        return this.children
    }

    /**
     * Getter of the parent and the direct children of the entity.
     *
     * Verifies if the entity has a parent. If so adds it to the list just created.
     * Adds all the entity's children to that same list.
     *
     * @return List with the parent of the entity and its children.
     */
    fun get_Parent_and_Children(): List<Entity>{

        val list = mutableListOf<Entity>()
        // Adiciona o pai
        this.get_Parent()?.let { parent ->
            list.add(parent)
        }
        // Adiciona os filhos
        list.addAll(this.get_Children())

        return list
    }
}

//fun Document.add_global_attribute_vis(entity_name: String, attribute_name: String, attribute_value: String){
//    var att: Attribute? = null
//    this.entities.forEach(){
//        var att_list = it.get_attributes()
//        att_list.forEach(){
//            if (it.name==entity_name && it.value==attribute_value) {
//                att = it
//                return@forEach
//            }
//        }
//    }
//    if (att == null)
//        att = Attribute(name=attribute_name, value=attribute_value)
//
//    val attCopy = att
//
//    // Para preservar a variável att, que pode ser modificada dentro da expressão do visitor
//    this.accept {
//            if (entity_name == it.name && attCopy != null)
//                it.addAttribute(attCopy!!)
//            true
//    }
//}

/**
 * Class that represents a document with a name and a list of entities.
 * @property[name] Name of the document.
 * @property[entities] List of entities contained in the document.
 */
class Document(
    var name: String,
    val entities: MutableList <Entity> = mutableListOf()
) {

    /**
     * Accepts a visitor function to process this entity and its children.
     *
     * Applies the provided [visitor] function to this entity and recursively to all of its children.
     * The visitor function should return true to continue visiting other entities, or false to stop the process.
     * @param visitor The visitor function to be applied to this entity and its children.
     */
    // Dunno x2
    fun accept(visitor: (Entity) -> Boolean) {
        entities.forEach {
                it.accept(visitor)
            }
    }

    /**
     * Adds an entity to the document.
     * Adds to the list of entities the [entity].
     * @param[entity] The entity to be added to the document.
     */
    fun addEntity(entity: Entity) {
        entities.add(entity)
    }

    /**
     * Removes an entity from the document.
     * It goes to the list of entities of the document and removes the one given as [entity].
     * @param[entity] The entity to be removed from the document.
     */
    fun removeEntity(entity: Entity) {
//        entities.forEach() {
//            if (it == entity)
//                entities.remove(it)
//        }
        entities.removeIf { it == entity }
    }

    /**
     * Does the pretty print by calling an auxiliary function.
     * @param[entity] The root entity or the entity where the pretty print begins.
     * @return Call another function that deals with the construction of the structure of the xml File.
     */
    fun prettyPrint(entity: Entity, indent: String = ""): String {
//        val stringBuilder = StringBuilder()
//
//        stringBuilder.append("$indent<${entity.name}")
//        if (entity.attributes.isNotEmpty()) {
//            entity.attributes.forEach { attribute ->
//                stringBuilder.append(" ${attribute.name}=\"${attribute.value}\"")
//            }
//        }
//
//        if (entity.children.isEmpty() && entity.text.isEmpty()) {
//            stringBuilder.append("/>")
//        } else {
//            stringBuilder.append(">")
//
//            if (entity.text.isNotEmpty())
//                stringBuilder.append("${entity.text}")
//
//            if (entity.children.isNotEmpty()) {
//                stringBuilder.appendLine()
//                entity.children.forEach { child ->
//                    stringBuilder.append(prettyPrint(child, "$indent    "))
//                    stringBuilder.appendLine()
//                }
//                stringBuilder.append("$indent")
//            }
//
//            if (entity.children.isNotEmpty() || entity.text.isNotEmpty()) {
//                stringBuilder.append("</${entity.name}>")
//            }
//        }

        return get_entity_xml(entity = entity, indent = indent, pretty_print = true)
    }

    /**
     * Does the pretty print and write it down in a given File.
     * @param[entity] The root entity or the entity where the pretty print begins.
     * @param[outputFile] File where the pretty print should be written
     * @return Call another function that deals with the construction of the structure of the xml File and
     * write it in the File.
     */
    fun prettyPrintToFile(entity: Entity, indent: String = "", outputFile: File) {
        val xmlString = prettyPrint(entity, indent)
        outputFile.writeText(xmlString)
    }

    /**
     * Adds attributes to the document globally.
     *
     * Creates a new attribute with the [attribute_name] and the [attribute_value].
     * Filters from the document's list of entities those which have the name [entity_name].
     * The attribute just created is added to those entities.
     *
     * @param[entity_name] Name of the entities to which an attribute will be added.
     * @param[attribute_name] Name of the attribute to be added.
     * @param[attribute_value] Value of the attribute to be added.
     */
    // Ponto 6
    fun add_global_attribute(entity_name: String, attribute_name: String, attribute_value: String) {
        // Procura ou cria o atributo
        val attribute = Attribute(attribute_name, attribute_value)

        // Adiciona o atributo a todas as entidades com o nome especificado
        this.entities.filter { it.name == entity_name }
            .forEach {
                it.addAttribute(attribute)
            }
    }

    /**
     * Renames entities to the document globally.
     *
     * It searches from the document's list of entities those which name is [old_name].
     * Renames those entities with [new_name].
     *
     * @param[old_name] Current name of the entities - to be renamed.
     * @param[new_name] Future name of the entities - to replace the current.
     */
    // Ponto 7
    fun rename_global_entity(old_name: String, new_name:String){
        this.entities.forEach(){
            if (old_name == it.name) {
                it.name=new_name
            }
        }
    }

    /**
     * Renames attributes of the document globally.
     *
     * Checks the document's list of entities and verifies if there are any entities with the name [entity_name].
     * If so, goes through the list of attributes of each one of those entities and verifies if there are any attributes
     * with the same name as the [old_attribute_name].
     * If so, renames the current name of that attribute to [new_attribute_name].
     *
     * @param[entity_name] Name of the entities where the attributes are.
     * @param[old_attribute_name] Current name of the attribute - to be renamed.
     * @param[new_attribute_name] Future name of the attribute - to replace the current.
     */
    // Ponto 8
    fun rename_global_attributes(entity_name: String, old_attribute_name: String, new_attribute_name: String){
        entities.forEach(){
            if (entity_name == it.name) {
                it.attributes.forEach(){
                    if (it.name==old_attribute_name)
                        it.name=new_attribute_name
                }
            }
        }
    }

    /**
     * Removes the entity from the document globally.
     *
     * Goes through the document's list of entities and verifies if there are any entities with the same name as [entity_name].
     * If so, adds them to the list recently created.
     * At the end, removes the list of unwanted entities from the document's list of entities.
     *
     * @param[entity_name] Name of the entity to be removed.
     */
    // Ponto 9
    fun remove_global_entities(entity_name: String){
        val list: MutableList <Entity> = mutableListOf()
        entities.forEach(){
            if (entity_name == it.name) {
                list.add(it)
            }
        }
        entities.removeAll(list)
    }

    // Ponto 10
//    fun remove_global_attributes(entity_name: String, attribute_name: String) {
//        val list: MutableList <Entity> = mutableListOf()
//        entities.forEach(){
//            if (entity_name == it.name) {
//                it.attributes.forEach(){
//                    if (it.name == attribute_name)
//                        list.add(it)
//                }
//                it.attributes.removeAll(list)
//            }
//        }
//    }

    /**
     * Removes attributes of the document globally.
     *
     * Iterates over the document's list of entities and removes the attributes which name is [attribute_name]
     * and belong to the entities which name is [entity_name].
     *
     * @param[entity_name] Name of the entities which contain the attributes.
     * @param[attribute_name] Name of the attributes to be removed.
     */
    fun remove_global_attributes(entity_name: String, attribute_name: String) {
        entities.forEach { entity ->
            if (entity_name == entity.name) {
                val attributesToRemove = entity.attributes.filter { it.name == attribute_name }
                entity.attributes.removeAll(attributesToRemove)
            }
        }
    }

    /**
     * Creates a String that contains the elements of each entity (name, text, attributes).
     *
     * If it's called by the "pretty_print" function, the Boolean variable "pretty_print" will be True
     * and so the String of the entity's children will also be added recursively to the structure.
     *
     * @param[entity] The entity where the pretty print should start. If there is no pretty print, it's
     * the entity String.
     * @param[pretty_print] Defines if it's a String or a pretty print structure.
     * @return Structure of the resulting pretty print.
     */
    fun get_entity_xml(entity: Entity, pretty_print: Boolean = false, indent: String = ""): String{
        val stringBuilder = StringBuilder()

        stringBuilder.append("$indent<${entity.name}")
        if (entity.attributes.isNotEmpty()) {
            entity.attributes.forEach { attribute ->
                stringBuilder.append(" ${attribute.name}=\"${attribute.value}\"")
            }
        }

        if (entity.children.isEmpty() && entity.text.isEmpty()) {
            stringBuilder.append("/>")
        } else {
            stringBuilder.append(">")

            if (entity.text.isNotEmpty())
                stringBuilder.append("${entity.text}")

            // No caso de ir buscar os filhos da entidade (no caso da função ser usada para pretty_print)
            if (pretty_print){
                if (entity.children.isNotEmpty()) {
                    stringBuilder.appendLine()
                    entity.children.forEach { child ->
                        stringBuilder.append(prettyPrint(child, "$indent    "))
                        stringBuilder.appendLine()
                    }
                    stringBuilder.append("$indent")
                }
            }
            if (entity.children.isNotEmpty() || entity.text.isNotEmpty()) {
                stringBuilder.append("</${entity.name}>")
            }
        }
        return stringBuilder.toString()
    }


//    fun aux_get_entity_with_x_path(x_path: String, entities_list: List<Entity>): Entity? {
//        val first_entity = x_path.substringBefore("/")
//        val other_entities = x_path.substringAfter("/")
//
//        entities_list.forEach {
//            if (first_entity == it.name) {
//                if (other_entities.isEmpty()) {
//                    return it
//                } else {
//                    return aux_get_entity_with_x_path(other_entities, it.get_Children())
//                }
//            }
//        }
//
//        return null

//    fun aux_get_entity_with_x_path(x_path: String, entity_to_explore: Entity): MutableList<Entity> {
//
//        val foundEntities = mutableListOf<Entity>()
//
//        val parts = x_path.split("/")
//        val first_entity = parts.first()
//        val other_entities = parts.drop(1).joinToString("/")
//
////        if (first_entity == entity_to_explore?.name && other_entities == ""){
////            println("Acabei " + entity_to_explore)
////            foundEntities.add(entity_to_explore)
////        }
//
//
//        var entities_list = entity_to_explore.get_Children()
//        println("List" + entities_list)
//        val foundEntity = entities_list.find { it.name == first_entity }
//
//        println("foundEntity" + foundEntity)
//        println("Other entities " + other_entities)
//
////        if (first_entity == foundEntity?.name && other_entities == ""){
////            println("Acabei " + foundEntity)
////            foundEntities.add(foundEntity)
////        }
////
////        if (foundEntity != null && other_entities.isNotEmpty()) {
////            println("Vai abaixo")
////            return aux_get_entity_with_x_path(other_entities, foundEntity)
////        }
//
//        if (foundEntity != null) {
//            if (other_entities.isEmpty()) {
//                foundEntities.add(foundEntity)
//            } else {
//                val childEntities = aux_get_entity_with_x_path(other_entities, foundEntity)
//                foundEntities.addAll(childEntities)
//            }
//        }
//
//        return foundEntities
//    }




    /**
     * For each split in the XPath String ("/"), it searches for the entity name where is equal to the first
     * sub-string of the split (entity most to the left of the split character) - "first_entity".
     *
     * If it finds entities that exist in the [entities_to_explore] list and the entities have the same name as
     * the first sub-string, there are 2 possible scenarios:
     *
     *      1st - the path ends up there, which means the "other_entities" variable is empty and adds the entity to
     * "foundEntities" list.
     *
     *      2nd - there are more entities in the path and so calls the function to its children.
     *
     * At the end of the path, if the entity exists, it is added to the list of foundEntities.
     *
     * @param[x_path] Micro-XPath with the possible path of entities.
     * @param[entities_to_explore] Document's list of entities.
     * @return List of the found entities.
     */
    fun aux_get_entity_with_x_path(x_path: String, entities_to_explore: List<Entity>): List<Entity> {
    val foundEntities = mutableListOf<Entity>()

    val parts = x_path.split("/")
    val first_entity = parts.first()
    val other_entities = parts.drop(1).joinToString("/")

    val matchingEntities = entities_to_explore.filter { it.name == first_entity }

    println("Matching entities " + matchingEntities)

    matchingEntities.forEach { entity ->
        if (other_entities.isEmpty()) {
            println("Adicionei " + entity)
            foundEntities.add(entity)
        } else {
            val childEntities = aux_get_entity_with_x_path(other_entities, entity.get_Children())
            println("Adicionei crianças " + childEntities)
            foundEntities.addAll(childEntities)
        }
    }

    return foundEntities
}

    /**
     * Given a path, joins all the entities that the auxiliary function "aux_get_entity_with_x_path"
     * relates to the [x_path].
     *
     * @param[x_path] Micro-XPath with the possible path of entities.
     * @return String with the final path of the found entities.
     */
    fun get_entity_with_x_path(x_path: String): String {
        val stringBuilder = StringBuilder()
        val returned_entities = aux_get_entity_with_x_path(x_path, entities)
        println(returned_entities)
        if (returned_entities != null) {
            returned_entities.forEachIndexed { index, entity ->
                stringBuilder.append(get_entity_xml(entity))
                if (index != returned_entities.size - 1)
                    stringBuilder.append("\n")
            }
        }
        return stringBuilder.toString()
    }
}

/**
 * NOTE: The following functions are another version of the exercises using visitors.
 * These functions are related to the class Document.
 */
// Funções usando objetos Visitor (Ponto 5)

// Relativas a Entidades, usando Documento

// As funções têm de estar relacionada com um Documento, de modo a serem percorridas as entidades disponíveis no mesmo,
// ao ser usado o método de Visitante.


/**
 * Searches for the parent of an entity.
 *
 * Looks for the parent of the given [child_entity] from the root of the document's hierarchy of entities.
 *
 * @param[child_entity] The child entity for which to find the parent.
 * @return The parent entity of the [child_entity]. If not found, returns null.
 */

fun Document.get_Parent_vis(child_entity: Entity): Entity?{
    var result: Entity? = null
    this.accept { entity ->
        if (entity == child_entity.get_Parent()) {
            result = entity
        }
        true
    }
    return result
}

/**
 * Searches for the children of an entity.
 *
 * Starts looking for the children at the beginning of the document's structure and saves all the children
 * whose parent is the [parent_entity].
 *
 * @param[parent_entity] The parent entity for which to find its children.
 * @return The list of children of the [parent_entity].
 */
fun Document.get_Children_vis(parent_entity: Entity) : List<Entity> {
    val list = mutableListOf<Entity>()

    this.accept { entity ->
        if (entity.parent == parent_entity){
            list.add(entity)
        }

        true
    }
    return list
}

/**
 * Looks for the parent and children of an entity.
 *
 * Starts at the root of the document and seeks the parent of the [main_entity] and the entity's children.
 * As it goes on the hierarchy, it saves the entities in a list.
 *
 * @param[main_entity] The entity for which to find its parent and children.
 * @return List with the parent and children of the entity given.
 */
fun Document.get_Parent_and_Children_vis(main_entity: Entity): List<Entity>{

    val list = mutableListOf<Entity>()

    this.accept { entity ->
        if (entity in main_entity.get_Children() || entity == main_entity.get_Parent()) {
            list.add(entity)
        }
        true
    }
    return list
}

// Relativas a Documentos

/**
 * Adds a global attribute to a document.
 *
 * Creates an attribute with the [attribute_name] and the [attribute_value].
 * Looks for the entities which name is the same as the [entity_name].
 * As it goes on the hierarchy, it adds the recently created attribute as a global attribute to the entities
 * which verify the previous condition.
 *
 * @param[entity_name] Name of the entities to which the attribute will be added.
 * @param[attribute_name] Name of the attribute to be added.
 * @param[attribute_value] Value of the attribute ti be added.
 */
fun Document.add_global_attribute_vis(entity_name: String, attribute_name: String, attribute_value: String) {

    val attribute = Attribute(attribute_name, attribute_value)

    this.accept {
        if (entity_name == it.name) {
            it.addAttribute(attribute)
        }
        true
    }
}

/**
 * Renames entities to the document globally.
 *
 * It goes through the hierarchy of the document and looks for the entities which name is [old_name].
 * Renames them with [new_name].
 *
 * @param[old_name] Current name of the entities - to be renamed.
 * @param[new_name] Future name of the entities - to replace the current.
 */
// Ponto 7
fun Document.rename_global_entity_vis(old_name: String, new_name:String){
    this.accept {
        if (old_name == it.name) {
            it.name=new_name
        }
        true
    }
}

/**
 * Renames global attributes of the document.
 *
 * Starting at the root, goes through the hierarchy of entities of the document and renames the global attributes
 * of the entities which name is [entity_name].
 * Changes the name of the global attributes which current name is [old_attribute_name] to [new_attribute_name].
 *
 * @param[entity_name] Name of the entities where the attributes are.
 * @param[old_attribute_name] Current name of the attributes - to be renamed.
 * @param[new_attribute_name] Future name of the attributes - to replace the current.
 */
// Ponto 8
fun Document.rename_global_attributes_vis(entity_name: String, old_attribute_name: String, new_attribute_name: String){
    this.accept {
        if (entity_name == it.name) {
            it.attributes.forEach(){
                if (it.name==old_attribute_name)
                    it.name=new_attribute_name
            }
        }
        true
    }
}

/**
 * Removes the entity from the document globally.
 *
 * Goes through the hierarchy of the document, starting at the root, and looks for the entities which name is
 * [entity_name].Removes from the document's entities list those which fulfill the previous condition.
 *
 * @param[entity_name] Name of the entities to be removed.
 */
// Ponto 9
fun Document.remove_global_entities_vis(entity_name: String) {
    this.accept { entity ->
        if (entity.name == entity_name) {
            entities.remove(entity)
        }
        true
    }
}

// Ponto 10
//fun Document.remove_global_attributes_vis(entity_name: String, attribute_name: String){
//    this.accept { entity ->
//        if (entity_name == entity.name) {
//            entity.attributes.forEach(){
//                if (it.name==attribute_name)
//                    entity.attributes.remove(it)
//            }
//        }
//        true
//    }
//}

/**
 * Removes attributes of the document globally.
 *
 * Starts at the beginning of the hierarchy of the document and looks for the entities which name is [entity_name].
 * Filters the attributes which name is [attribute_name] and when found all the entities and respective attributes,
 * removes all those attributes globally from the document.
 *
 * @param[entity_name] Name of the entities which contain the attributes.
 * @param[attribute_name] Name of the attributes to be removed.
 */

fun Document.remove_global_attributes_vis(entity_name: String, attribute_name: String) {
    this.accept { entity ->
        if (entity_name == entity.name) {
            val attributesToRemove = entity.attributes.filter { it.name == attribute_name }
            attributesToRemove.forEach { attribute ->
                entity.attributes.remove(attribute)
            }
        }
        true
    }
}

