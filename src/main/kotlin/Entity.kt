/**
 * @author Ana Mercês Soares dos Reis Moreira - nº99352
 * @author Inês Colaço Ascenso - nº99286
 */

/**
 * Class that represents an entity with a name, a text, a list of attributes, a parent and a list of children.
 * @property[name] Name of the entity.
 * @property[text] Text of the entity.
 * @property[attributes] List of attributes of the entity.
 * @property[parent] Parent of the entity.
 * @property[children] List of children (also entities) generated by the entity.
 */

class Entity(
    private var name: String,
    private var text: String = "",
    private val attributes: MutableList <Attribute> = mutableListOf(),
    private val parent: Entity? = null,
    private val children: MutableList<Entity> = mutableListOf()
){

    /**
     * Initializes an instance of Entity.
     *
     * If the name given has more than one word, the entity is not created
     * @param[name] The name given to the entity
     *
     * If a parent entity is given, adds the entity to the list of children of the parent.
     * @param[parent] The parent of the entity. If it is null, this entity will be considered a root entity.
     */
    init{
        require(name.split(" ").size == 1) {
            "Name of entity must contain only one word"
        }
        if (parent?.getEntityText()?.isNotBlank() == true)
            throw IllegalStateException("Parent entity already has text and cannot have children.")
        parent?.children?.add(this)
    }

    /**
     * Returns a String representation of the entity.
     * @return A String representation of the entity.
     */
    override fun toString(): String {
        return "Entity(name='$name' text='$text', attributes='$attributes', parent='$parent')"
    }

    /**
     * Accepts a visitor function to process this entity.
     *
     * This function invokes the provided [visitor] function passing this entity as its argument.
     * The visitor function is expected to return a boolean value.
     *
     * @param[visitor] The visitor function to be invoked with this entity as its argument.
     * @return The boolean value returned by the visitor.
     */
    fun accept(visitor: (Entity) -> Boolean){
        visitor(this)
    }

    /**
     * Getter of the name of the entity.
     * @return The name of the entity.
     */
    fun getName(): String {
        return name
    }

    /**
     * Changes the current name of the entity with the new one given.
     * @param[name] The new name of the entity.
     */
    fun setName(name: String){
        this.name=name
    }

    /**
     * Searches if the entity has already an attribute with the corresponding name and value as the ones given.
     * @param[name] The name of the attribute to look for.
     * @param[value] The value of the attribute to look for.
     */
    private fun equalAttribute(name: String?, value: String?): Attribute? {
        return attributes.find { it.getAttributeName().equals(name) && it.getAttributeValue().equals(value) }
    }

    // Relating Attributes

    // Point 2.
    /**
     * Adds a given [attribute] to the list of attributes of the entity.
     * @param[attribute] The attribute to be added to the entity.
     */
    fun addAttribute(attribute: Attribute){
        if (equalAttribute(attribute.getAttributeName(), attribute.getAttributeValue()) != null) {
            throw IllegalStateException("Entity already has this attribute.")
        } else {
            this.attributes.add(attribute)
        }
    }

    // Point 2.
    /**
     * Removes a given [attribute] from the list of attributes of the entity.
     * @param[attribute] The attribute to be removed from the entity.
     */
    fun removeAttribute(attribute: Attribute){
        attributes.removeIf { it == attribute }
    }

    // Point 2.
    /**
     * Changes the name and/or the value of a given [attribute].
     * Searches for the given attribute in the list of attributes of the entity and updates the name and/or value.
     *
     * @param[attribute] The attribute to be changed.
     * @param[new_name] The name of the attribute to replace the current name. By default, it's null, if there is no change.
     * @param[new_value] The value of the attribute to replace the current value. By default, it's null, if there is no change.
     */
    fun changeAttribute(attribute: Attribute, new_name: String? = null, new_value: String? = null) {
        attributes.forEach {
            if (it == attribute) {

                var aux_name = new_name
                var aux_value = new_value

                if (new_name == null)
                    aux_name = it.getAttributeName()
                if (new_value == null)
                    aux_value = it.getAttributeValue()

                if (equalAttribute(aux_name, aux_value) != null) {
                    throw IllegalStateException("Entity already has this attribute.")
                } else {
                    if (new_name != null)
                        it.setAttributeName(new_name)
                    if (new_value != null)
                        it.setAttributeValue(new_value)
                }
            }
        }
    }

    /**
     * Getter of the list of attributes of the entity.
     * @return List of attributes of the entity.
     */
    fun getAttributes(): MutableList<Attribute>{
        return this.attributes
    }

    // Relating entities text
    /**
     * Getter of the text that belongs to the entity.
     * @return Text related to the entity.
     */
    fun getEntityText(): String{
        return this.text
    }

    /**
     * Changes the text of the entity.
     * Updates the current text with the given [new_text].
     * @param[new_text] The text to replace the current text of the entity.
     */
    fun changeEntityText(new_text: String){
        if (children.isNotEmpty()) {
            throw IllegalStateException("Entity already has children and cannot have text.")
        }
        text=new_text
    }

    /**
     * Removes the text of the entity.
     * Clears the current text of the entity, sets it to an empty String ("").
     */
    fun removeEntityText(){
        text=""
    }

    // Relating parent and childrens

    // Point 3.
    /**
     * Getter of the entity's parent.
     * If the parent doesn't exist, the entity is the root and will return null.
     * @return The parent of the entity. If there is no parent, it returns null.
     */
    fun getParent(): Entity?{
        return this.parent
    }

    // Point 3.
    /**
     * Getter of all the descendants of the entity (children, grandchildren, great-grandchildren, etc.).
     *
     * It gets recursively the children of each entity that is related to the entity, placing its direct and
     * indirect descendants into a list and returning it at the end.
     *
     * @return List of all the descendant entities of the entity.
     */
    // Counting the children of the children
    fun getAllChildren() : List<Entity> {
        val list: MutableList<Entity> = mutableListOf()
        this.children.forEach {
            list.add(it)
            list.addAll(it.getAllChildren())
        }
        return list
    }

    // Point 3.
    /**
     * Getter of the direct children of the entity.
     * @return List of children of the entity.
     */
    // Not counting the children of the children
    fun getChildren() : List<Entity> {
        return this.children
    }

    // Point 3.
    /**
     * Getter of the parent and the direct children of the entity.
     *
     * Verifies if the entity has a parent. If so adds it to the list just created.
     * Adds all the entity's children to that same list.
     *
     * @return List with the parent of the entity and its children.
     */
    fun getParentAndChildren(): List<Entity>{

        val list = mutableListOf<Entity>()
        this.getParent()?.let { parent ->
            list.add(parent)
        }
        list.addAll(this.getChildren())

        return list
    }
}