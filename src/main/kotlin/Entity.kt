/**
 * @author Ana Mercês Soares dos Reis Moreira - nº99352
 * @author Inês Colaço Ascenso - nº99286
 */

/**
 * Class that represents an entity with a name, a text, a list of attributes, a parent and a list of children.
 * @property[name] Name of the entity.
 * @property[text] Text of the entity.
 * @property[attributes] List of attributes of the entity.
 * @property[parent] Parent of the entity.
 * @property[children] List of children (also entities) generated by the entity.
 */

class Entity(
    private var name: String,
    private var text: String = "",
    private val attributes: MutableList <Attribute> = mutableListOf(),
    private val parent: Entity? = null,
    private val children: MutableList<Entity> = mutableListOf()
){

    /**
     * Initializes an instance of Entity.
     *
     * If the name given has more than one word, the entity is not created
     * @param[name] The name given to the entity
     *
     * If a parent entity is given, adds the entity to the list of children of the parent.
     * @param[parent] The parent of the entity. If it is null, this entity will be considered a root entity.
     */
    init{
        require(name.split(" ").size == 1) {
            "Name of entity must contain only one word"
        }
        if (parent?.get_entity_text()?.isNotBlank() == true)
            throw IllegalStateException("Parent entity already has text and cannot have children.")
        parent?.children?.add(this)
    }

    /**
     * Returns a String representation of the entity.
     * @return A String representation of the entity.
     */
    override fun toString(): String {
        return "Entity(name='$name' text='$text', attributes='$attributes', parent='$parent')"
    }

    /**
     * Accepts a visitor function to process this entity.
     *
     * This function invokes the provided [visitor] function passing this entity as its argument.
     * The visitor function is expected to return a boolean value.
     *
     * @param[visitor] The visitor function to be invoked with this entity as its argument.
     * @return The boolean value returned by the visitor.
     */
    fun accept(visitor: (Entity) -> Boolean){
        visitor(this)
    }

    fun get_name(): String {
        return name
    }

    fun set_name(name: String){
        this.name=name
    }

    private fun equal_attribute(name: String?, value: String?): Attribute? {
        return attributes.find { it.get_attribute_name().equals(name) && it.get_attribute_value().equals(value) }
    }

    // Relating Attributes

    // Point 2.
    /**
     * Adds a given [attribute] to the list of attributes of the entity.
     * @param[attribute] The attribute to be added to the entity.
     */
    fun add_attribute(attribute: Attribute){
        if (equal_attribute(attribute.get_attribute_name(), attribute.get_attribute_value()) != null) {
            throw IllegalStateException("Entity already has this attribute.")
        } else {
            this.attributes.add(attribute)
        }
    }

    // Point 2.
    /**
     * Removes a given [attribute] from the list of attributes of the entity.
     * @param[attribute] The attribute to be removed from the entity.
     */
    fun remove_attribute(attribute: Attribute){
        attributes.removeIf { it == attribute }
    }

    // Point 2.
    /**
     * Changes the name and/or the value of a given [attribute].
     * Searches for the given attribute in the list of attributes of the entity and updates the name and/or value.
     *
     * @param[attribute] The attribute to be changed.
     * @param[new_name] The name of the attribute to replace the current name. By default, it's null, if there is no change.
     * @param[new_value] The value of the attribute to replace the current value. By default, it's null, if there is no change.
     */
    fun change_attribute(attribute: Attribute, new_name: String? = null, new_value: String? = null) {
//        attributes.forEach {
//            if (it == attribute) {
//                if (new_name != null) {
//                    require(new_name.split(" ").size == 1) {
//                        "New name must contain only one word"
//                    }
//                    val last_name = it.name
//                    it.name = new_name
//                    if (attributes.filter{ attribute.name == it.name && attribute.value == it.value}.size != 0){
//                        print("This entity already has one equal attribute")
//                        it.name = last_name
//                    }
//                }
//                if (new_value != null) {
//                    val last_value = it.value
//                    it.value = new_value
//                    if (attributes.filter{ attribute.name == it.name && attribute.value == it.value}.size != 0){
//                        print("This entity already has one equal attribute")
//                        it.value = last_value
//                    }
//                }
//            }
//        }



        attributes.forEach {
            if (it == attribute) {

                var aux_name = new_name
                var aux_value = new_value

                if (new_name == null)
                    aux_name = it.get_attribute_name()
                if (new_value == null)
                    aux_value = it.get_attribute_value()

                if (equal_attribute(aux_name, aux_value) != null) {
                    throw IllegalStateException("Entity already has this attribute.")
                } else {
                    if (new_name != null)
                        it.set_attribute_name(new_name)
                    if (new_value != null)
                        it.set_attribute_value(new_value)
                }
            }
        }
    }

    /**
     * Getter of the list of attributes of the entity.
     * @return List of attributes of the entity.
     */
    fun get_attributes(): MutableList<Attribute>{
        return this.attributes
    }

    // Relating entities text
    /**
     * Getter of the text that belongs to the entity.
     * @return Text related to the entity.
     */
    fun get_entity_text(): String{
        return this.text
    }

    /**
     * Changes the text of the entity.
     * Updates the current text with the given [new_text].
     * @param[new_text] The text to replace the current text of the entity.
     */
    fun change_entity_text(new_text: String){
        if (children.isNotEmpty()) {
            throw IllegalStateException("Entity already has children and cannot have text.")
        }
        text=new_text
    }

    /**
     * Removes the text of the entity.
     * Clears the current text of the entity, sets it to an empty String ("").
     *
     */
    fun remove_entity_text(){
        text=""
    }

    // Relating parent and childrens

    // Point 3.
    /**
     * Getter of the entity's parent.
     * If the parent doesn't exist, the entity is the root and will return null.
     * @return The parent of the entity. If there is no parent, it returns null.
     */
    fun get_parent(): Entity?{
        return this.parent
    }

    // Point 3.
    /**
     * Getter of all the descendants of the entity (children, grandchildren, great-grandchildren, etc.).
     *
     * It gets recursively the children of each entity that is related to the entity, placing its direct and
     * indirect descendants into a list and returning it at the end.
     *
     * @return List of all the descendant entities of the entity.
     */
    // Counting the children of the children
    fun get_all_children() : List<Entity> {
        val list: MutableList<Entity> = mutableListOf()
        this.children.forEach {
            list.add(it)
            list.addAll(it.get_all_children())
        }
        return list
    }

    // Point 3.
    /**
     * Getter of the direct children of the entity.
     * @return List of children of the entity.
     */
    // Not counting the children of the children
    fun get_children() : List<Entity> {
        return this.children
    }

    // Point 3.
    /**
     * Getter of the parent and the direct children of the entity.
     *
     * Verifies if the entity has a parent. If so adds it to the list just created.
     * Adds all the entity's children to that same list.
     *
     * @return List with the parent of the entity and its children.
     */
    fun get_parent_and_children(): List<Entity>{

        val list = mutableListOf<Entity>()
        this.get_parent()?.let { parent ->
            list.add(parent)
        }
        list.addAll(this.get_children())

        return list
    }
}